// ===== PACKAGE.JSON =====
{
  "name": "katikaname-backend",
  "version": "1.0.0",
  "description": "Backend API for KatikaNaMe - Creative Professional Platform",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest"
  },
  "dependencies": {
    "express": "^4.18.2",
    "mongoose": "^8.0.0",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "dotenv": "^16.3.1",
    "multer": "^1.4.5-lts.1",
    "pdfkit": "^0.13.0",
    "puppeteer": "^21.5.0",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2",
    "express-rate-limit": "^7.1.5",
    "express-validator": "^7.0.1",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.0",
    "compression": "^1.7.4",
    "morgan": "^1.10.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.1",
    "jest": "^29.7.0",
    "supertest": "^6.3.3"
  },
  "keywords": ["dance", "music", "art", "portfolio", "creative", "platform"],
  "author": "KatikaNaMe Team",
  "license": "MIT"
}

// ===== SERVER.JS =====
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const morgan = require('morgan');
const rateLimit = require('express-rate-limit');
require('dotenv').config();

// Import routes
const artistRoutes = require('./routes/artists');
const portfolioRoutes = require('./routes/portfolios');
const contractRoutes = require('./routes/contracts');
const adminRoutes = require('./routes/admin');
const swaggerSetup = require('./config/swagger');

const app = express();
const PORT = process.env.PORT || 3000;

// Security middleware
app.use(helmet({
  crossOriginResourcePolicy: { policy: "cross-origin" }
}));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later.'
});
app.use('/api/', limiter);

// CORS configuration
app.use(cors({
  origin: process.env.FRONTEND_URL || '*',
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

// Body parsing middleware
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Compression and logging
app.use(compression());
app.use(morgan('combined'));

// Static files
app.use('/uploads', express.static('uploads'));

// Database connection
mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/katikaname', {
  useNewUrlParser: true,
  useUnifiedTopology: true,
})
.then(() => console.log('Connected to MongoDB'))
.catch(err => console.error('MongoDB connection error:', err));

// Routes
app.use('/api/artists', artistRoutes);
app.use('/api/portfolios', portfolioRoutes);
app.use('/api/contracts', contractRoutes);
app.use('/api/admin', adminRoutes);

// Swagger documentation
swaggerSetup(app);

// Health check endpoint
app.get('/health', (req, res) => {
  res.status(200).json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  });
});

// Root endpoint
app.get('/', (req, res) => {
  res.json({
    message: 'Welcome to KatikaNaMe API',
    version: '1.0.0',
    documentation: '/api-docs'
  });
});

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(err.status || 500).json({
    error: {
      message: err.message || 'Internal Server Error',
      ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
    }
  });
});

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({ error: 'Route not found' });
});

app.listen(PORT, () => {
  console.log(`KatikaNaMe Backend running on port ${PORT}`);
  console.log(`API Documentation available at http://localhost:${PORT}/api-docs`);
});

module.exports = app;

// ===== MODELS/ARTIST.JS =====
const mongoose = require('mongoose');

const artistSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true,
    maxlength: 100
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    match: [/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/, 'Please enter a valid email']
  },
  bio: {
    type: String,
    required: true,
    maxlength: 1000
  },
  category: {
    type: String,
    required: true,
    enum: ['dancer', 'musician', 'visual_artist', 'multi_disciplinary']
  },
  genres: [{
    type: String,
    trim: true
  }],
  experience: {
    type: String,
    required: true,
    enum: ['beginner', 'intermediate', 'advanced', 'professional']
  },
  location: {
    city: String,
    country: String,
    coordinates: {
      lat: Number,
      lng: Number
    }
  },
  socialLinks: {
    instagram: String,
    youtube: String,
    tiktok: String,
    website: String,
    other: String
  },
  media: [{
    type: {
      type: String,
      enum: ['image', 'video', 'pdf'],
      required: true
    },
    filename: String,
    originalName: String,
    url: String,
    uploadDate: {
      type: Date,
      default: Date.now
    }
  }],
  portfolio: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Portfolio'
  },
  isActive: {
    type: Boolean,
    default: true
  },
  isVerified: {
    type: Boolean,
    default: false
  },
  rating: {
    average: {
      type: Number,
      default: 0,
      min: 0,
      max: 5
    },
    count: {
      type: Number,
      default: 0
    }
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

// Indexes for better query performance
artistSchema.index({ category: 1, genres: 1, location: 1 });
artistSchema.index({ email: 1 });
artistSchema.index({ name: 'text', bio: 'text' });

// Update timestamp on save
artistSchema.pre('save', function(next) {
  this.updatedAt = Date.now();
  next();
});

module.exports = mongoose.model('Artist', artistSchema);

// ===== MODELS/PORTFOLIO.JS =====
const mongoose = require('mongoose');

const portfolioSchema = new mongoose.Schema({
  artist: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Artist',
    required: true
  },
  template: {
    type: String,
    enum: ['modern', 'classic', 'creative', 'minimal'],
    default: 'modern'
  },
  title: {
    type: String,
    required: true,
    maxlength: 200
  },
  description: String,
  sections: [{
    type: {
      type: String,
      enum: ['about', 'experience', 'gallery', 'testimonials', 'contact'],
      required: true
    },
    title: String,
    content: String,
    media: [{
      type: String, // URLs to media files
    }],
    order: Number
  }],
  customizations: {
    colors: {
      primary: { type: String, default: '#000000' },
      secondary: { type: String, default: '#ffffff' },
      accent: { type: String, default: '#ff6b6b' }
    },
    fonts: {
      heading: { type: String, default: 'Arial' },
      body: { type: String, default: 'Arial' }
    },
    layout: {
      type: String,
      enum: ['grid', 'masonry', 'slider'],
      default: 'grid'
    }
  },
  generatedFiles: [{
    format: {
      type: String,
      enum: ['pdf', 'html'],
    },
    filename: String,
    url: String,
    generatedAt: {
      type: Date,
      default: Date.now
    }
  }],
  isPublic: {
    type: Boolean,
    default: true
  },
  views: {
    type: Number,
    default: 0
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

portfolioSchema.pre('save', function(next) {
  this.updatedAt = Date.now();
  next();
});

module.exports = mongoose.model('Portfolio', portfolioSchema);

// ===== MODELS/CONTRACT.JS =====
const mongoose = require('mongoose');

const contractSchema = new mongoose.Schema({
  type: {
    type: String,
    required: true,
    enum: ['performance', 'teaching', 'collaboration', 'commission', 'licensing']
  },
  title: String,
  description: String,
  template: String, // Path to contract template
  guidelines: [{
    section: String,
    tips: [String]
  }],
  legalRequirements: [{
    jurisdiction: String,
    requirements: [String]
  }],
  sampleClauses: [{
    clause: String,
    description: String,
    isRequired: Boolean
  }],
  createdAt: {
    type: Date,
    default: Date.now
  }
});

module.exports = mongoose.model('Contract', contractSchema);

// ===== MODELS/ADMIN.JS =====
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const adminSchema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
    unique: true,
    trim: true
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true
  },
  password: {
    type: String,
    required: true,
    minlength: 6
  },
  role: {
    type: String,
    enum: ['admin', 'moderator'],
    default: 'moderator'
  },
  permissions: [{
    type: String,
    enum: ['read', 'write', 'delete', 'approve']
  }],
  lastLogin: Date,
  isActive: {
    type: Boolean,
    default: true
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

// Hash password before saving
adminSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  this.password = await bcrypt.hash(this.password, 10);
  next();
});

// Compare password method
adminSchema.methods.comparePassword = async function(password) {
  return bcrypt.compare(password, this.password);
};

module.exports = mongoose.model('Admin', adminSchema);

// ===== ROUTES/ARTISTS.JS =====
const express = require('express');
const multer = require('multer');
const path = require('path');
const { body, validationResult } = require('express-validator');
const Artist = require('../models/Artist');
const router = express.Router();

// Configure multer for file uploads
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/artists/');
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({
  storage: storage,
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB limit
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = /jpeg|jpg|png|gif|pdf|mp4|mov|avi/;
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
    const mimetype = allowedTypes.test(file.mimetype);
    
    if (mimetype && extname) {
      return cb(null, true);
    } else {
      cb(new Error('Invalid file type. Only images, PDFs, and videos are allowed.'));
    }
  }
});

// Validation middleware
const validateArtist = [
  body('name').trim().isLength({ min: 2, max: 100 }).escape(),
  body('email').isEmail().normalizeEmail(),
  body('bio').trim().isLength({ min: 10, max: 1000 }).escape(),
  body('category').isIn(['dancer', 'musician', 'visual_artist', 'multi_disciplinary']),
  body('experience').isIn(['beginner', 'intermediate', 'advanced', 'professional']),
  body('genres').optional().isArray(),
  body('location.city').optional().trim().escape(),
  body('location.country').optional().trim().escape()
];

/**
 * @swagger
 * /api/artists:
 *   post:
 *     summary: Create a new artist profile
 *     tags: [Artists]
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *               email:
 *                 type: string
 *               bio:
 *                 type: string
 *               category:
 *                 type: string
 *                 enum: [dancer, musician, visual_artist, multi_disciplinary]
 *               experience:
 *                 type: string
 *                 enum: [beginner, intermediate, advanced, professional]
 *               files:
 *                 type: array
 *                 items:
 *                   type: string
 *                   format: binary
 */
router.post('/', upload.array('files', 10), validateArtist, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const artistData = {
      ...req.body,
      genres: req.body.genres ? JSON.parse(req.body.genres) : [],
      location: req.body.location ? JSON.parse(req.body.location) : {},
      socialLinks: req.body.socialLinks ? JSON.parse(req.body.socialLinks) : {}
    };

    // Process uploaded files
    if (req.files && req.files.length > 0) {
      artistData.media = req.files.map(file => ({
        type: file.mimetype.startsWith('image/') ? 'image' : 
              file.mimetype.startsWith('video/') ? 'video' : 'pdf',
        filename: file.filename,
        originalName: file.originalname,
        url: `/uploads/artists/${file.filename}`
      }));
    }

    const artist = new Artist(artistData);
    await artist.save();

    res.status(201).json({
      message: 'Artist profile created successfully',
      artist: artist
    });
  } catch (error) {
    if (error.code === 11000) {
      return res.status(400).json({ error: 'Email already exists' });
    }
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/artists:
 *   get:
 *     summary: Get all artists with optional filtering
 *     tags: [Artists]
 *     parameters:
 *       - in: query
 *         name: category
 *         schema:
 *           type: string
 *       - in: query
 *         name: genre
 *         schema:
 *           type: string
 *       - in: query
 *         name: experience
 *         schema:
 *           type: string
 *       - in: query
 *         name: location
 *         schema:
 *           type: string
 *       - in: query
 *         name: search
 *         schema:
 *           type: string
 */
router.get('/', async (req, res) => {
  try {
    const { category, genre, experience, location, search, page = 1, limit = 20 } = req.query;
    
    // Build filter object
    const filter = { isActive: true };
    
    if (category) filter.category = category;
    if (genre) filter.genres = { $in: [genre] };
    if (experience) filter.experience = experience;
    if (location) {
      filter.$or = [
        { 'location.city': new RegExp(location, 'i') },
        { 'location.country': new RegExp(location, 'i') }
      ];
    }
    
    // Text search
    if (search) {
      filter.$text = { $search: search };
    }

    const skip = (page - 1) * limit;
    
    const artists = await Artist.find(filter)
      .select('-email') // Don't expose email addresses publicly
      .skip(skip)
      .limit(parseInt(limit))
      .sort({ createdAt: -1 });

    const total = await Artist.countDocuments(filter);

    res.json({
      artists,
      pagination: {
        current: parseInt(page),
        pages: Math.ceil(total / limit),
        total
      }
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/artists/{id}:
 *   get:
 *     summary: Get artist by ID
 *     tags: [Artists]
 */
router.get('/:id', async (req, res) => {
  try {
    const artist = await Artist.findById(req.params.id)
      .populate('portfolio')
      .select('-email');
    
    if (!artist) {
      return res.status(404).json({ error: 'Artist not found' });
    }

    res.json(artist);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/artists/{id}:
 *   put:
 *     summary: Update artist profile
 *     tags: [Artists]
 */
router.put('/:id', upload.array('files', 10), validateArtist, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const updateData = { ...req.body };
    
    // Parse JSON strings if they exist
    if (req.body.genres) updateData.genres = JSON.parse(req.body.genres);
    if (req.body.location) updateData.location = JSON.parse(req.body.location);
    if (req.body.socialLinks) updateData.socialLinks = JSON.parse(req.body.socialLinks);

    // Handle new file uploads
    if (req.files && req.files.length > 0) {
      const newMedia = req.files.map(file => ({
        type: file.mimetype.startsWith('image/') ? 'image' : 
              file.mimetype.startsWith('video/') ? 'video' : 'pdf',
        filename: file.filename,
        originalName: file.originalname,
        url: `/uploads/artists/${file.filename}`
      }));
      
      updateData.$push = { media: { $each: newMedia } };
    }

    const artist = await Artist.findByIdAndUpdate(
      req.params.id,
      updateData,
      { new: true, runValidators: true }
    );

    if (!artist) {
      return res.status(404).json({ error: 'Artist not found' });
    }

    res.json({
      message: 'Artist profile updated successfully',
      artist
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/artists/{id}:
 *   delete:
 *     summary: Delete artist profile (soft delete)
 *     tags: [Artists]
 */
router.delete('/:id', async (req, res) => {
  try {
    const artist = await Artist.findByIdAndUpdate(
      req.params.id,
      { isActive: false },
      { new: true }
    );

    if (!artist) {
      return res.status(404).json({ error: 'Artist not found' });
    }

    res.json({ message: 'Artist profile deactivated successfully' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;

// ===== ROUTES/PORTFOLIOS.JS =====
const express = require('express');
const PDFDocument = require('pdfkit');
const fs = require('fs');
const path = require('path');
const Portfolio = require('../models/Portfolio');
const Artist = require('../models/Artist');
const router = express.Router();

/**
 * @swagger
 * /api/portfolios:
 *   post:
 *     summary: Create a new portfolio
 *     tags: [Portfolios]
 */
router.post('/', async (req, res) => {
  try {
    const { artistId, template, title, description, sections, customizations } = req.body;

    // Verify artist exists
    const artist = await Artist.findById(artistId);
    if (!artist) {
      return res.status(404).json({ error: 'Artist not found' });
    }

    const portfolio = new Portfolio({
      artist: artistId,
      template: template || 'modern',
      title,
      description,
      sections: sections || [],
      customizations: customizations || {}
    });

    await portfolio.save();

    // Update artist with portfolio reference
    artist.portfolio = portfolio._id;
    await artist.save();

    res.status(201).json({
      message: 'Portfolio created successfully',
      portfolio
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/portfolios/{id}/generate-pdf:
 *   post:
 *     summary: Generate PDF portfolio
 *     tags: [Portfolios]
 */
router.post('/:id/generate-pdf', async (req, res) => {
  try {
    const portfolio = await Portfolio.findById(req.params.id).populate('artist');
    
    if (!portfolio) {
      return res.status(404).json({ error: 'Portfolio not found' });
    }

    // Ensure uploads directory exists
    const uploadsDir = path.join(__dirname, '../uploads/portfolios');
    if (!fs.existsSync(uploadsDir)) {
      fs.mkdirSync(uploadsDir, { recursive: true });
    }

    const filename = `portfolio-${portfolio._id}-${Date.now()}.pdf`;
    const filepath = path.join(uploadsDir, filename);

    // Create PDF document
    const doc = new PDFDocument({
      margin: 50,
      size: 'A4'
    });

    // Pipe PDF to file
    doc.pipe(fs.createWriteStream(filepath));

    // Add content to PDF
    const { primary, secondary, accent } = portfolio.customizations.colors;
    
    // Title page
    doc.fontSize(28)
       .fillColor(primary || '#000000')
       .text(portfolio.title, { align: 'center' })
       .moveDown();

    doc.fontSize(16)
       .fillColor('#666666')
       .text(`Portfolio by ${portfolio.artist.name}`, { align: 'center' })
       .moveDown(2);

    if (portfolio.description) {
      doc.fontSize(12)
         .fillColor('#333333')
         .text(portfolio.description, { align: 'justify' })
         .moveDown(2);
    }

    // Add sections
    portfolio.sections.forEach((section, index) => {
      if (index > 0) doc.addPage();
      
      doc.fontSize(18)
         .fillColor(accent || '#ff6b6b')
         .text(section.title || section.type.toUpperCase(), { underline: true })
         .moveDown();

      if (section.content) {
        doc.fontSize(11)
           .fillColor('#333333')
           .text(section.content, { align: 'justify' })
           .moveDown();
      }
    });

    // Artist info page
    doc.addPage()
       .fontSize(18)
       .fillColor(accent || '#ff6b6b')
       .text('About the Artist', { underline: true })
       .moveDown();

    doc.fontSize(11)
       .fillColor('#333333')
       .text(`Name: ${portfolio.artist.name}`)
       .text(`Category: ${portfolio.artist.category.replace('_', ' ').toUpperCase()}`)
       .text(`Experience: ${portfolio.artist.experience.toUpperCase()}`)
       .moveDown();

    if (portfolio.artist.bio) {
      doc.text(portfolio.artist.bio, { align: 'justify' });
    }

    // Contact information
    if (portfolio.artist.socialLinks) {
      doc.moveDown()
         .fontSize(14)
         .fillColor(accent || '#ff6b6b')
         .text('Connect:', { underline: true })
         .moveDown(0.5);

      Object.entries(portfolio.artist.socialLinks).forEach(([platform, url]) => {
        if (url) {
          doc.fontSize(10)
             .fillColor('#0066cc')
             .text(`${platform.toUpperCase()}: ${url}`, { link: url });
        }
      });
    }

    // Finalize PDF
    doc.end();

    // Wait for PDF to be written
    doc.on('end', async () => {
      try {
        const url = `/uploads/portfolios/${filename}`;
        
        // Save generated file info to portfolio
        portfolio.generatedFiles.push({
          format: 'pdf',
          filename,
          url,
          generatedAt: new Date()
        });
        
        await portfolio.save();

        res.json({
          message: 'Portfolio PDF generated successfully',
          downloadUrl: url,
          filename
        });
      } catch (error) {
        res.status(500).json({ error: 'Failed to save portfolio file info' });
      }
    });

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/portfolios/{id}:
 *   get:
 *     summary: Get portfolio by ID
 *     tags: [Portfolios]
 */
router.get('/:id', async (req, res) => {
  try {
    const portfolio = await Portfolio.findById(req.params.id)
      .populate('artist', '-email');
    
    if (!portfolio) {
      return res.status(404).json({ error: 'Portfolio not found' });
    }

    // Increment view count
    portfolio.views += 1;
    await portfolio.save();

    res.json(portfolio);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/portfolios:
 *   get:
 *     summary: Get all portfolios
 *     tags: [Portfolios]
 */
router.get('/', async (req, res) => {
  try {
    const { page = 1, limit = 20, public_only = true } = req.query;
    
    const filter = public_only === 'true' ? { isPublic: true } : {};
    const skip = (page - 1) * limit;

    const portfolios = await Portfolio.find(filter)
      .populate('artist', 'name category experience')
      .skip(skip)
      .limit(parseInt(limit))
      .sort({ createdAt: -1 });

    const total = await Portfolio.countDocuments(filter);

    res.json({
      portfolios,
      pagination: {
        current: parseInt(page),
        pages: Math.ceil(total / limit),
        total
      }
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/portfolios/{id}:
 *   put:
 *     summary: Update portfolio
 *     tags: [Portfolios]
 */
router.put('/:id', async (req, res) => {
  try {
    const portfolio = await Portfolio.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true, runValidators: true }
    ).populate('artist', '-email');

    if (!portfolio) {
      return res.status(404).json({ error: 'Portfolio not found' });
    }

    res.json({
      message: 'Portfolio updated successfully',
      portfolio
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;

// ===== ROUTES/CONTRACTS.JS =====
const express = require('express

// ===== PACKAGE.JSON =====
{
  "name": "katikaname-backend",
  "version": "1.0.0",
  "description": "Backend API for KatikaNaMe - Creative Professional Platform",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest"
  },
  "dependencies": {
    "express": "^4.18.2",
    "mongoose": "^8.0.0",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "dotenv": "^16.3.1",
    "multer": "^1.4.5-lts.1",
    "pdfkit": "^0.13.0",
    "puppeteer": "^21.5.0",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2",
    "express-rate-limit": "^7.1.5",
    "express-validator": "^7.0.1",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.0",
    "compression": "^1.7.4",
    "morgan": "^1.10.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.1",
    "jest": "^29.7.0",
    "supertest": "^6.3.3"
  },
  "keywords": ["dance", "music", "art", "portfolio", "creative", "platform"],
  "author": "KatikaNaMe Team",
  "license": "MIT"
}

// ===== SERVER.JS =====
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const morgan = require('morgan');
const rateLimit = require('express-rate-limit');
require('dotenv').config();

// Import routes
const artistRoutes = require('./routes/artists');
const portfolioRoutes = require('./routes/portfolios');
const contractRoutes = require('./routes/contracts');
const adminRoutes = require('./routes/admin');
const swaggerSetup = require('./config/swagger');

const app = express();
const PORT = process.env.PORT || 3000;

// Security middleware
app.use(helmet({
  crossOriginResourcePolicy: { policy: "cross-origin" }
}));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later.'
});
app.use('/api/', limiter);

// CORS configuration
app.use(cors({
  origin: process.env.FRONTEND_URL || '*',
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

// Body parsing middleware
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Compression and logging
app.use(compression());
app.use(morgan('combined'));

// Static files
app.use('/uploads', express.static('uploads'));

// Database connection
mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/katikaname', {
  useNewUrlParser: true,
  useUnifiedTopology: true,
})
.then(() => console.log('Connected to MongoDB'))
.catch(err => console.error('MongoDB connection error:', err));

// Routes
app.use('/api/artists', artistRoutes);
app.use('/api/portfolios', portfolioRoutes);
app.use('/api/contracts', contractRoutes);
app.use('/api/admin', adminRoutes);

// Swagger documentation
swaggerSetup(app);

// Health check endpoint
app.get('/health', (req, res) => {
  res.status(200).json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  });
});

// Root endpoint
app.get('/', (req, res) => {
  res.json({
    message: 'Welcome to KatikaNaMe API',
    version: '1.0.0',
    documentation: '/api-docs'
  });
});

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(err.status || 500).json({
    error: {
      message: err.message || 'Internal Server Error',
      ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
    }
  });
});

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({ error: 'Route not found' });
});

app.listen(PORT, () => {
  console.log(`KatikaNaMe Backend running on port ${PORT}`);
  console.log(`API Documentation available at http://localhost:${PORT}/api-docs`);
});

module.exports = app;

// ===== MODELS/ARTIST.JS =====
const mongoose = require('mongoose');

const artistSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true,
    maxlength: 100
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    match: [/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/, 'Please enter a valid email']
  },
  bio: {
    type: String,
    required: true,
    maxlength: 1000
  },
  category: {
    type: String,
    required: true,
    enum: ['dancer', 'musician', 'visual_artist', 'multi_disciplinary']
  },
  genres: [{
    type: String,
    trim: true
  }],
  experience: {
    type: String,
    required: true,
    enum: ['beginner', 'intermediate', 'advanced', 'professional']
  },
  location: {
    city: String,
    country: String,
    coordinates: {
      lat: Number,
      lng: Number
    }
  },
  socialLinks: {
    instagram: String,
    youtube: String,
    tiktok: String,
    website: String,
    other: String
  },
  media: [{
    type: {
      type: String,
      enum: ['image', 'video', 'pdf'],
      required: true
    },
    filename: String,
    originalName: String,
    url: String,
    uploadDate: {
      type: Date,
      default: Date.now
    }
  }],
  portfolio: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Portfolio'
  },
  isActive: {
    type: Boolean,
    default: true
  },
  isVerified: {
    type: Boolean,
    default: false
  },
  rating: {
    average: {
      type: Number,
      default: 0,
      min: 0,
      max: 5
    },
    count: {
      type: Number,
      default: 0
    }
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

// Indexes for better query performance
artistSchema.index({ category: 1, genres: 1, location: 1 });
artistSchema.index({ email: 1 });
artistSchema.index({ name: 'text', bio: 'text' });

// Update timestamp on save
artistSchema.pre('save', function(next) {
  this.updatedAt = Date.now();
  next();
});

module.exports = mongoose.model('Artist', artistSchema);

// ===== MODELS/PORTFOLIO.JS =====
const mongoose = require('mongoose');

const portfolioSchema = new mongoose.Schema({
  artist: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Artist',
    required: true
  },
  template: {
    type: String,
    enum: ['modern', 'classic', 'creative', 'minimal'],
    default: 'modern'
  },
  title: {
    type: String,
    required: true,
    maxlength: 200
  },
  description: String,
  sections: [{
    type: {
      type: String,
      enum: ['about', 'experience', 'gallery', 'testimonials', 'contact'],
      required: true
    },
    title: String,
    content: String,
    media: [{
      type: String, // URLs to media files
    }],
    order: Number
  }],
  customizations: {
    colors: {
      primary: { type: String, default: '#000000' },
      secondary: { type: String, default: '#ffffff' },
      accent: { type: String, default: '#ff6b6b' }
    },
    fonts: {
      heading: { type: String, default: 'Arial' },
      body: { type: String, default: 'Arial' }
    },
    layout: {
      type: String,
      enum: ['grid', 'masonry', 'slider'],
      default: 'grid'
    }
  },
  generatedFiles: [{
    format: {
      type: String,
      enum: ['pdf', 'html'],
    },
    filename: String,
    url: String,
    generatedAt: {
      type: Date,
      default: Date.now
    }
  }],
  isPublic: {
    type: Boolean,
    default: true
  },
  views: {
    type: Number,
    default: 0
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

portfolioSchema.pre('save', function(next) {
  this.updatedAt = Date.now();
  next();
});

module.exports = mongoose.model('Portfolio', portfolioSchema);

// ===== MODELS/CONTRACT.JS =====
const mongoose = require('mongoose');

const contractSchema = new mongoose.Schema({
  type: {
    type: String,
    required: true,
    enum: ['performance', 'teaching', 'collaboration', 'commission', 'licensing']
  },
  title: String,
  description: String,
  template: String, // Path to contract template
  guidelines: [{
    section: String,
    tips: [String]
  }],
  legalRequirements: [{
    jurisdiction: String,
    requirements: [String]
  }],
  sampleClauses: [{
    clause: String,
    description: String,
    isRequired: Boolean
  }],
  createdAt: {
    type: Date,
    default: Date.now
  }
});

module.exports = mongoose.model('Contract', contractSchema);

// ===== MODELS/ADMIN.JS =====
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const adminSchema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
    unique: true,
    trim: true
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true
  },
  password: {
    type: String,
    required: true,
    minlength: 6
  },
  role: {
    type: String,
    enum: ['admin', 'moderator'],
    default: 'moderator'
  },
  permissions: [{
    type: String,
    enum: ['read', 'write', 'delete', 'approve']
  }],
  lastLogin: Date,
  isActive: {
    type: Boolean,
    default: true
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

// Hash password before saving
adminSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  this.password = await bcrypt.hash(this.password, 10);
  next();
});

// Compare password method
adminSchema.methods.comparePassword = async function(password) {
  return bcrypt.compare(password, this.password);
};

module.exports = mongoose.model('Admin', adminSchema);

// ===== ROUTES/ARTISTS.JS =====
const express = require('express');
const multer = require('multer');
const path = require('path');
const { body, validationResult } = require('express-validator');
const Artist = require('../models/Artist');
const router = express.Router();

// Configure multer for file uploads
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/artists/');
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({
  storage: storage,
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB limit
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = /jpeg|jpg|png|gif|pdf|mp4|mov|avi/;
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
    const mimetype = allowedTypes.test(file.mimetype);
    
    if (mimetype && extname) {
      return cb(null, true);
    } else {
      cb(new Error('Invalid file type. Only images, PDFs, and videos are allowed.'));
    }
  }
});

// Validation middleware
const validateArtist = [
  body('name').trim().isLength({ min: 2, max: 100 }).escape(),
  body('email').isEmail().normalizeEmail(),
  body('bio').trim().isLength({ min: 10, max: 1000 }).escape(),
  body('category').isIn(['dancer', 'musician', 'visual_artist', 'multi_disciplinary']),
  body('experience').isIn(['beginner', 'intermediate', 'advanced', 'professional']),
  body('genres').optional().isArray(),
  body('location.city').optional().trim().escape(),
  body('location.country').optional().trim().escape()
];

/**
 * @swagger
 * /api/artists:
 *   post:
 *     summary: Create a new artist profile
 *     tags: [Artists]
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *               email:
 *                 type: string
 *               bio:
 *                 type: string
 *               category:
 *                 type: string
 *                 enum: [dancer, musician, visual_artist, multi_disciplinary]
 *               experience:
 *                 type: string
 *                 enum: [beginner, intermediate, advanced, professional]
 *               files:
 *                 type: array
 *                 items:
 *                   type: string
 *                   format: binary
 */
router.post('/', upload.array('files', 10), validateArtist, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const artistData = {
      ...req.body,
      genres: req.body.genres ? JSON.parse(req.body.genres) : [],
      location: req.body.location ? JSON.parse(req.body.location) : {},
      socialLinks: req.body.socialLinks ? JSON.parse(req.body.socialLinks) : {}
    };

    // Process uploaded files
    if (req.files && req.files.length > 0) {
      artistData.media = req.files.map(file => ({
        type: file.mimetype.startsWith('image/') ? 'image' : 
              file.mimetype.startsWith('video/') ? 'video' : 'pdf',
        filename: file.filename,
        originalName: file.originalname,
        url: `/uploads/artists/${file.filename}`
      }));
    }

    const artist = new Artist(artistData);
    await artist.save();

    res.status(201).json({
      message: 'Artist profile created successfully',
      artist: artist
    });
  } catch (error) {
    if (error.code === 11000) {
      return res.status(400).json({ error: 'Email already exists' });
    }
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/artists:
 *   get:
 *     summary: Get all artists with optional filtering
 *     tags: [Artists]
 *     parameters:
 *       - in: query
 *         name: category
 *         schema:
 *           type: string
 *       - in: query
 *         name: genre
 *         schema:
 *           type: string
 *       - in: query
 *         name: experience
 *         schema:
 *           type: string
 *       - in: query
 *         name: location
 *         schema:
 *           type: string
 *       - in: query
 *         name: search
 *         schema:
 *           type: string
 */
router.get('/', async (req, res) => {
  try {
    const { category, genre, experience, location, search, page = 1, limit = 20 } = req.query;
    
    // Build filter object
    const filter = { isActive: true };
    
    if (category) filter.category = category;
    if (genre) filter.genres = { $in: [genre] };
    if (experience) filter.experience = experience;
    if (location) {
      filter.$or = [
        { 'location.city': new RegExp(location, 'i') },
        { 'location.country': new RegExp(location, 'i') }
      ];
    }
    
    // Text search
    if (search) {
      filter.$text = { $search: search };
    }

    const skip = (page - 1) * limit;
    
    const artists = await Artist.find(filter)
      .select('-email') // Don't expose email addresses publicly
      .skip(skip)
      .limit(parseInt(limit))
      .sort({ createdAt: -1 });

    const total = await Artist.countDocuments(filter);

    res.json({
      artists,
      pagination: {
        current: parseInt(page),
        pages: Math.ceil(total / limit),
        total
      }
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/artists/{id}:
 *   get:
 *     summary: Get artist by ID
 *     tags: [Artists]
 */
router.get('/:id', async (req, res) => {
  try {
    const artist = await Artist.findById(req.params.id)
      .populate('portfolio')
      .select('-email');
    
    if (!artist) {
      return res.status(404).json({ error: 'Artist not found' });
    }

    res.json(artist);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/artists/{id}:
 *   put:
 *     summary: Update artist profile
 *     tags: [Artists]
 */
router.put('/:id', upload.array('files', 10), validateArtist, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const updateData = { ...req.body };
    
    // Parse JSON strings if they exist
    if (req.body.genres) updateData.genres = JSON.parse(req.body.genres);
    if (req.body.location) updateData.location = JSON.parse(req.body.location);
    if (req.body.socialLinks) updateData.socialLinks = JSON.parse(req.body.socialLinks);

    // Handle new file uploads
    if (req.files && req.files.length > 0) {
      const newMedia = req.files.map(file => ({
        type: file.mimetype.startsWith('image/') ? 'image' : 
              file.mimetype.startsWith('video/') ? 'video' : 'pdf',
        filename: file.filename,
        originalName: file.originalname,
        url: `/uploads/artists/${file.filename}`
      }));
      
      updateData.$push = { media: { $each: newMedia } };
    }

    const artist = await Artist.findByIdAndUpdate(
      req.params.id,
      updateData,
      { new: true, runValidators: true }
    );

    if (!artist) {
      return res.status(404).json({ error: 'Artist not found' });
    }

    res.json({
      message: 'Artist profile updated successfully',
      artist
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/artists/{id}:
 *   delete:
 *     summary: Delete artist profile (soft delete)
 *     tags: [Artists]
 */
router.delete('/:id', async (req, res) => {
  try {
    const artist = await Artist.findByIdAndUpdate(
      req.params.id,
      { isActive: false },
      { new: true }
    );

    if (!artist) {
      return res.status(404).json({ error: 'Artist not found' });
    }

    res.json({ message: 'Artist profile deactivated successfully' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;

// ===== ROUTES/PORTFOLIOS.JS =====
const express = require('express');
const PDFDocument = require('pdfkit');
const fs = require('fs');
const path = require('path');
const Portfolio = require('../models/Portfolio');
const Artist = require('../models/Artist');
const router = express.Router();

/**
 * @swagger
 * /api/portfolios:
 *   post:
 *     summary: Create a new portfolio
 *     tags: [Portfolios]
 */
router.post('/', async (req, res) => {
  try {
    const { artistId, template, title, description, sections, customizations } = req.body;

    // Verify artist exists
    const artist = await Artist.findById(artistId);
    if (!artist) {
      return res.status(404).json({ error: 'Artist not found' });
    }

    const portfolio = new Portfolio({
      artist: artistId,
      template: template || 'modern',
      title,
      description,
      sections: sections || [],
      customizations: customizations || {}
    });

    await portfolio.save();

    // Update artist with portfolio reference
    artist.portfolio = portfolio._id;
    await artist.save();

    res.status(201).json({
      message: 'Portfolio created successfully',
      portfolio
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/portfolios/{id}/generate-pdf:
 *   post:
 *     summary: Generate PDF portfolio
 *     tags: [Portfolios]
 */
router.post('/:id/generate-pdf', async (req, res) => {
  try {
    const portfolio = await Portfolio.findById(req.params.id).populate('artist');
    
    if (!portfolio) {
      return res.status(404).json({ error: 'Portfolio not found' });
    }

    // Ensure uploads directory exists
    const uploadsDir = path.join(__dirname, '../uploads/portfolios');
    if (!fs.existsSync(uploadsDir)) {
      fs.mkdirSync(uploadsDir, { recursive: true });
    }

    const filename = `portfolio-${portfolio._id}-${Date.now()}.pdf`;
    const filepath = path.join(uploadsDir, filename);

    // Create PDF document
    const doc = new PDFDocument({
      margin: 50,
      size: 'A4'
    });

    // Pipe PDF to file
    doc.pipe(fs.createWriteStream(filepath));

    // Add content to PDF
    const { primary, secondary, accent } = portfolio.customizations.colors;
    
    // Title page
    doc.fontSize(28)
       .fillColor(primary || '#000000')
       .text(portfolio.title, { align: 'center' })
       .moveDown();

    doc.fontSize(16)
       .fillColor('#666666')
       .text(`Portfolio by ${portfolio.artist.name}`, { align: 'center' })
       .moveDown(2);

    if (portfolio.description) {
      doc.fontSize(12)
         .fillColor('#333333')
         .text(portfolio.description, { align: 'justify' })
         .moveDown(2);
    }

    // Add sections
    portfolio.sections.forEach((section, index) => {
      if (index > 0) doc.addPage();
      
      doc.fontSize(18)
         .fillColor(accent || '#ff6b6b')
         .text(section.title || section.type.toUpperCase(), { underline: true })
         .moveDown();

      if (section.content) {
        doc.fontSize(11)
           .fillColor('#333333')
           .text(section.content, { align: 'justify' })
           .moveDown();
      }
    });

    // Artist info page
    doc.addPage()
       .fontSize(18)
       .fillColor(accent || '#ff6b6b')
       .text('About the Artist', { underline: true })
       .moveDown();

    doc.fontSize(11)
       .fillColor('#333333')
       .text(`Name: ${portfolio.artist.name}`)
       .text(`Category: ${portfolio.artist.category.replace('_', ' ').toUpperCase()}`)
       .text(`Experience: ${portfolio.artist.experience.toUpperCase()}`)
       .moveDown();

    if (portfolio.artist.bio) {
      doc.text(portfolio.artist.bio, { align: 'justify' });
    }

    // Contact information
    if (portfolio.artist.socialLinks) {
      doc.moveDown()
         .fontSize(14)
         .fillColor(accent || '#ff6b6b')
         .text('Connect:', { underline: true })
         .moveDown(0.5);

      Object.entries(portfolio.artist.socialLinks).forEach(([platform, url]) => {
        if (url) {
          doc.fontSize(10)
             .fillColor('#0066cc')
             .text(`${platform.toUpperCase()}: ${url}`, { link: url });
        }
      });
    }

    // Finalize PDF
    doc.end();

    // Wait for PDF to be written
    doc.on('end', async () => {
      try {
        const url = `/uploads/portfolios/${filename}`;
        
        // Save generated file info to portfolio
        portfolio.generatedFiles.push({
          format: 'pdf',
          filename,
          url,
          generatedAt: new Date()
        });
        
        await portfolio.save();

        res.json({
          message: 'Portfolio PDF generated successfully',
          downloadUrl: url,
          filename
        });
      } catch (error) {
        res.status(500).json({ error: 'Failed to save portfolio file info' });
      }
    });

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/portfolios/{id}:
 *   get:
 *     summary: Get portfolio by ID
 *     tags: [Portfolios]
 */
router.get('/:id', async (req, res) => {
  try {
    const portfolio = await Portfolio.findById(req.params.id)
      .populate('artist', '-email');
    
    if (!portfolio) {
      return res.status(404).json({ error: 'Portfolio not found' });
    }

    // Increment view count
    portfolio.views += 1;
    await portfolio.save();

    res.json(portfolio);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/portfolios:
 *   get:
 *     summary: Get all portfolios
 *     tags: [Portfolios]
 */
router.get('/', async (req, res) => {
  try {
    const { page = 1, limit = 20, public_only = true } = req.query;
    
    const filter = public_only === 'true' ? { isPublic: true } : {};
    const skip = (page - 1) * limit;

    const portfolios = await Portfolio.find(filter)
      .populate('artist', 'name category experience')
      .skip(skip)
      .limit(parseInt(limit))
      .sort({ createdAt: -1 });

    const total = await Portfolio.countDocuments(filter);

    res.json({
      portfolios,
      pagination: {
        current: parseInt(page),
        pages: Math.ceil(total / limit),
        total
      }
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/portfolios/{id}:
 *   put:
 *     summary: Update portfolio
 *     tags: [Portfolios]
 */
router.put('/:id', async (req, res) => {
  try {
    const portfolio = await Portfolio.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true, runValidators: true }
    ).populate('artist', '-email');

    if (!portfolio) {
      return res.status(404).json({ error: 'Portfolio not found' });
    }

    res.json({
      message: 'Portfolio updated successfully',
      portfolio
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;

// ===== ROUTES/CONTRACTS.JS =====
const express = require('express');
const fs = require('fs');
const path = require('path');
const PDFDocument = require('pdfkit');
const Contract = require('../models/Contract');
const router = express.Router();

// Contract templates and guidelines
const contractData = {
  performance: {
    title: "Performance Contract",
    description: "For live performances, gigs, and shows",
    guidelines: [
      {
        section: "Essential Elements",
        tips: [
          "Clearly define performance date, time, and venue",
          "Specify duration of performance and number of sets",
          "Include sound check and rehearsal times",
          "Detail payment terms and schedule",
          "Outline cancellation policies for both parties"
        ]
      },
      {
        section: "Technical Requirements",
        tips: [
          "List all equipment and technical needs",
          "Specify who provides sound, lighting, and staging",
          "Include backup plans for technical failures",
          "Detail load-in and load-out procedures"
        ]
      },
      {
        section: "Rights and Responsibilities",
        tips: [
          "Clarify recording and photography rights",
          "Define promotional material usage",
          "Specify insurance and liability coverage",
          "Include force majeure clauses"
        ]
      }
    ],
    sampleClauses: [
      {
        clause: "Payment Terms",
        description: "The Client agrees to pay the Artist [AMOUNT] with [PERCENTAGE]% due upon signing and the remainder due [TIMEFRAME] after performance completion.",
        isRequired: true
      },
      {
        clause: "Cancellation Policy",
        description: "Either party may cancel with [NUMBER] days written notice. Cancellation fees apply as follows: [TERMS]",
        isRequired: true
      }
    ]
  },
  teaching: {
    title: "Teaching/Workshop Contract",
    description: "For dance classes, music lessons, and educational workshops",
    guidelines: [
      {
        section: "Scope of Work",
        tips: [
          "Define curriculum and learning objectives",
          "Specify class duration, frequency, and location",
          "Outline student skill levels and age groups",
          "Include materials and equipment requirements"
        ]
      },
      {
        section: "Payment Structure",
        tips: [
          "Clarify hourly rates vs. package deals",
          "Define payment schedule and late fees",
          "Include travel expenses if applicable",
          "Specify refund and makeup class policies"
        ]
      }
    ],
    sampleClauses: [
      {
        clause: "Liability Waiver",
        description: "Students participate at their own risk. Instructor is not liable for injuries occurring during instruction.",
        isRequired: true
      }
    ]
  },
  collaboration: {
    title: "Artistic Collaboration Agreement",
    description: "For joint creative projects between artists",
    guidelines: [
      {
        section: "Creative Control",
        tips: [
          "Define each party's creative contributions",
          "Establish decision-making processes",
          "Clarify artistic vision and direction",
          "Include dispute resolution mechanisms"
        ]
      },
      {
        section: "Intellectual Property",
        tips: [
          "Define ownership of created works",
          "Specify credit and attribution requirements",
          "Outline future use and modification rights",
          "Include revenue sharing agreements"
        ]
      }
    ],
    sampleClauses: [
      {
        clause: "Shared Ownership",
        description: "All creative works produced shall be jointly owned by collaborating parties in equal shares unless otherwise specified.",
        isRequired: false
      }
    ]
  },
  commission: {
    title: "Commission Agreement",
    description: "For custom artistic works and commissions",
    guidelines: [
      {
        section: "Project Specifications",
        tips: [
          "Detailed description of commissioned work",
          "Timeline with milestones and deadlines",
          "Revision rounds and approval process",
          "Final deliverable formats and specifications"
        ]
      },
      {
        section: "Rights and Usage",
        tips: [
          "Define client's usage rights",
          "Specify artist's portfolio rights",
          "Include moral rights considerations",
          "Outline resale and reproduction terms"
        ]
      }
    ],
    sampleClauses: [
      {
        clause: "Work for Hire",
        description: "This work is created as a work for hire, with all rights transferring to the Client upon full payment.",
        isRequired: false
      }
    ]
  },
  licensing: {
    title: "Licensing Agreement",
    description: "For licensing existing works or ongoing usage rights",
    guidelines: [
      {
        section: "License Scope",
        tips: [
          "Define specific rights being licensed",
          "Specify geographic and temporal limitations",
          "Clarify exclusive vs. non-exclusive rights",
          "Include permitted uses and restrictions"
        ]
      },
      {
        section: "Compensation",
        tips: [
          "Structure licensing fees appropriately",
          "Include royalty payment schedules",
          "Define minimum guarantees if applicable",
          "Specify audit and reporting requirements"
        ]
      }
    ],
    sampleClauses: [
      {
        clause: "Territory and Duration",
        description: "This license grants rights for use in [TERRITORY] for a period of [DURATION] from the effective date.",
        isRequired: true
      }
    ]
  }
};

/**
 * @swagger
 * /api/contracts/types:
 *   get:
 *     summary: Get all available contract types
 *     tags: [Contracts]
 */
router.get('/types', (req, res) => {
  try {
    const types = Object.keys(contractData).map(key => ({
      type: key,
      title: contractData[key].title,
      description: contractData[key].description
    }));
    
    res.json({ contractTypes: types });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/contracts/{type}/guidelines:
 *   get:
 *     summary: Get guidelines for specific contract type
 *     tags: [Contracts]
 */
router.get('/:type/guidelines', (req, res) => {
  try {
    const { type } = req.params;
    
    if (!contractData[type]) {
      return res.status(404).json({ error: 'Contract type not found' });
    }

    const contract = contractData[type];
    
    res.json({
      type,
      title: contract.title,
      description: contract.description,
      guidelines: contract.guidelines,
      sampleClauses: contract.sampleClauses
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/contracts/{type}/template:
 *   post:
 *     summary: Generate contract template PDF
 *     tags: [Contracts]
 */
router.post('/:type/template', async (req, res) => {
  try {
    const { type } = req.params;
    const { customData = {} } = req.body;
    
    if (!contractData[type]) {
      return res.status(404).json({ error: 'Contract type not found' });
    }

    const contract = contractData[type];
    
    // Ensure uploads directory exists
    const uploadsDir = path.join(__dirname, '../uploads/contracts');
    if (!fs.existsSync(uploadsDir)) {
      fs.mkdirSync(uploadsDir, { recursive: true });
    }

    const filename = `${type}-contract-template-${Date.now()}.pdf`;
    const filepath = path.join(uploadsDir, filename);

    // Create PDF document
    const doc = new PDFDocument({
      margin: 50,
      size: 'A4'
    });

    // Pipe PDF to file
    doc.pipe(fs.createWriteStream(filepath));

    // Header
    doc.fontSize(24)
       .fillColor('#2c3e50')
       .text(contract.title.toUpperCase(), { align: 'center' })
       .moveDown(2);

    // Description
    doc.fontSize(12)
       .fillColor('#555555')
       .text(contract.description, { align: 'center' })
       .moveDown(2);

    // Disclaimer
    doc.fontSize(10)
       .fillColor('#e74c3c')
       .text('DISCLAIMER: This is a template for educational purposes only. Consult with a legal professional before using any contract.', 
             { align: 'center' })
       .moveDown(2);

    // Contract template structure
    doc.fontSize(16)
       .fillColor('#2c3e50')
       .text('CONTRACT TEMPLATE', { underline: true })
       .moveDown();

    // Basic contract structure
    const contractSections = [
      'PARTIES',
      'SCOPE OF WORK',
      'COMPENSATION',
      'TIMELINE',
      'RESPONSIBILITIES',
      'RIGHTS AND OWNERSHIP',
      'CANCELLATION TERMS',
      'DISPUTE RESOLUTION',
      'SIGNATURES'
    ];

    contractSections.forEach((section, index) => {
      doc.fontSize(14)
         .fillColor('#34495e')
         .text(`${index + 1}. ${section}`)
         .moveDown(0.5);

      doc.fontSize(10)
         .fillColor('#7f8c8d')
         .text('[Insert specific terms and conditions for this section]')
         .moveDown();
    });

    // Add guidelines
    doc.addPage()
       .fontSize(18)
       .fillColor('#2c3e50')
       .text('GUIDELINES AND TIPS', { underline: true })
       .moveDown();

    contract.guidelines.forEach(guideline => {
      doc.fontSize(14)
         .fillColor('#34495e')
         .text(guideline.section, { underline: true })
         .moveDown(0.5);

      guideline.tips.forEach(tip => {
        doc.fontSize(11)
           .fillColor('#555555')
           .text(`• ${tip}`)
           .moveDown(0.3);
      });
      
      doc.moveDown();
    });

    // Sample clauses
    if (contract.sampleClauses && contract.sampleClauses.length > 0) {
      doc.addPage()
         .fontSize(18)
         .fillColor('#2c3e50')
         .text('SAMPLE CLAUSES', { underline: true })
         .moveDown();

      contract.sampleClauses.forEach(clause => {
        doc.fontSize(14)
           .fillColor(clause.isRequired ? '#e74c3c' : '#27ae60')
           .text(`${clause.clause} ${clause.isRequired ? '(REQUIRED)' : '(OPTIONAL)'}`)
           .moveDown(0.5);

        doc.fontSize(11)
           .fillColor('#555555')
           .text(clause.description)
           .moveDown();
      });
    }

    // Footer
    doc.fontSize(8)
       .fillColor('#95a5a6')
       .text('Generated by KatikaNaMe Platform - Creative Professional Contracts', 
             50, doc.page.height - 50, { align: 'center' });

    // Finalize PDF
    doc.end();

    // Wait for PDF to be written
    doc.on('end', () => {
      const url = `/uploads/contracts/${filename}`;
      
      res.json({
        message: 'Contract template generated successfully',
        downloadUrl: url,
        filename,
        type: contract.title
      });
    });

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/contracts:
 *   get:
 *     summary: Get all contracts from database
 *     tags: [Contracts]
 */
router.get('/', async (req, res) => {
  try {
    const contracts = await Contract.find().sort({ createdAt: -1 });
    res.json({ contracts });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/contracts:
 *   post:
 *     summary: Create custom contract in database
 *     tags: [Contracts]
 */
router.post('/', async (req, res) => {
  try {
    const contract = new Contract(req.body);
    await contract.save();
    
    res.status(201).json({
      message: 'Contract created successfully',
      contract
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;

// ===== ROUTES/ADMIN.JS =====
const express = require('express');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const { body, validationResult } = require('express-validator');
const Admin = require('../models/Admin');
const Artist = require('../models/Artist');
const Portfolio = require('../models/Portfolio');
const Contract = require('../models/Contract');
const router = express.Router();

// JWT middleware
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }

  jwt.verify(token, process.env.JWT_SECRET || 'fallback_secret', (err, user) => {
    if (err) {
      return res.status(403).json({ error: 'Invalid or expired token' });
    }
    req.user = user;
    next();
  });
};

// Permission middleware
const requirePermission = (permission) => {
  return (req, res, next) => {
    if (!req.user.permissions.includes(permission) && req.user.role !== 'admin') {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }
    next();
  };
};

/**
 * @swagger
 * /api/admin/login:
 *   post:
 *     summary: Admin login
 *     tags: [Admin]
 */
router.post('/login', [
  body('username').trim().notEmpty(),
  body('password').notEmpty()
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { username, password } = req.body;
    
    const admin = await Admin.findOne({ 
      $or: [{ username }, { email: username }],
      isActive: true 
    });
    
    if (!admin || !(await admin.comparePassword(password))) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Update last login
    admin.lastLogin = new Date();
    await admin.save();

    const token = jwt.sign(
      { 
        id: admin._id, 
        username: admin.username, 
        role: admin.role,
        permissions: admin.permissions 
      },
      process.env.JWT_SECRET || 'fallback_secret',
      { expiresIn: '24h' }
    );

    res.json({
      message: 'Login successful',
      token,
      admin: {
        id: admin._id,
        username: admin.username,
        email: admin.email,
        role: admin.role,
        permissions: admin.permissions
      }
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/admin/dashboard:
 *   get:
 *     summary: Get dashboard statistics
 *     tags: [Admin]
 */
router.get('/dashboard', authenticateToken, async (req, res) => {
  try {
    const [
      totalArtists,
      activeArtists,
      totalPortfolios,
      recentArtists,
      topCategories
    ] = await Promise.all([
      Artist.countDocuments(),
      Artist.countDocuments({ isActive: true }),
      Portfolio.countDocuments(),
      Artist.find({ isActive: true })
        .sort({ createdAt: -1 })
        .limit(5)
        .select('name category experience createdAt'),
      Artist.aggregate([
        { $match: { isActive: true } },
        { $group: { _id: '$category', count: { $sum: 1 } } },
        { $sort: { count: -1 } }
      ])
    ]);

    res.json({
      statistics: {
        totalArtists,
        activeArtists,
        totalPortfolios,
        inactiveArtists: totalArtists - activeArtists
      },
      recentArtists,
      topCategories
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/admin/artists:
 *   get:
 *     summary: Get all artists for admin
 *     tags: [Admin]
 */
router.get('/artists', authenticateToken, requirePermission('read'), async (req, res) => {
  try {
    const { page = 1, limit = 20, status, category } = req.query;
    
    const filter = {};
    if (status) filter.isActive = status === 'active';
    if (category) filter.category = category;

    const skip = (page - 1) * limit;
    
    const artists = await Artist.find(filter)
      .skip(skip)
      .limit(parseInt(limit))
      .sort({ createdAt: -1 });

    const total = await Artist.countDocuments(filter);

    res.json({
      artists,
      pagination: {
        current: parseInt(page),
        pages: Math.ceil(total / limit),
        total
      }
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/admin/artists/{id}/verify:
 *   patch:
 *     summary: Verify an artist
 *     tags: [Admin]
 */
router.patch('/artists/:id/verify', authenticateToken, requirePermission('approve'), async (req, res) => {
  try {
    const artist = await Artist.findByIdAndUpdate(
      req.params.id,
      { isVerified: true },
      { new: true }
    );

    if (!artist) {
      return res.status(404).json({ error: 'Artist not found' });
    }

    res.json({
      message: 'Artist verified successfully',
      artist
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/admin/artists/{id}/deactivate:
 *   patch:
 *     summary: Deactivate an artist
 *     tags: [Admin]
 */
router.patch('/artists/:id/deactivate', authenticateToken, requirePermission('write'), async (req, res) => {
  try {
    const { reason } = req.body;
    
    const artist = await Artist.findByIdAndUpdate(
      req.params.id,
      { 
        isActive: false,
        deactivationReason: reason,
        deactivatedAt: new Date(),
        deactivatedBy: req.user.id
      },
      { new: true }
    );

    if (!artist) {
      return res.status(404).json({ error: 'Artist not found' });
    }

    res.json({
      message: 'Artist deactivated successfully',
      artist
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/admin/portfolios:
 *   get:
 *     summary: Get all portfolios for admin
 *     tags: [Admin]
 */
router.get('/portfolios', authenticateToken, requirePermission('read'), async (req, res) => {
  try {
    const { page = 1, limit = 20 } = req.query;
    const skip = (page - 1) * limit;
    
    const portfolios = await Portfolio.find()
      .populate('artist', 'name email category')
      .skip(skip)
      .limit(parseInt(limit))
      .sort({ createdAt: -1 });

    const total = await Portfolio.countDocuments();

    res.json({
      portfolios,
      pagination: {
        current: parseInt(page),
        pages: Math.ceil(total / limit),
        total
      }
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @swagger
 * /api/admin/create-admin:
 *   post:
 *     summary: Create new admin (admin only)
 *     tags: [Admin]
 */
router.post('/create-admin', authenticateToken, async (req, res) => {
  try {
    // Only admins can create other admins
    if (req.user.role !== 'admin') {
      return res.status(403).json({ error: 'Only admins can create other admins' });
    }

    const { username, email, password, role = 'moderator', permissions = ['read'] } = req.body;
    
    const admin = new Admin({
      username,
      email,
      password,
      role,
      permissions
    });

    await admin.save();

    res.status(201).json({
      message: 'Admin created successfully',
      admin: {
        id: admin._id,
        username: admin.username,
        email: admin.email,
        role: admin.role,
        permissions: admin.permissions
      }
    });
  } catch (error) {
    if (error.code === 11000) {
      return res.status(400).json({ error: 'Username or email already exists' });
    }
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;

// ===== CONFIG/SWAGGER.JS =====
const swaggerJsdoc = require('swagger-jsdoc');
const swaggerUi = require('swagger-ui-express');

const options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'KatikaNaMe API',
      version: '1.0.0',
      description: 'Backend API for KatikaNaMe Creative Professional Platform',
      contact: {
        name: 'KatikaNaMe Team',
        email: 'support@katikaname.com'
      }
    },
    servers: [
      {
        url: process.env.API_BASE_URL || 'http://localhost:3000',
        description: 'Development server'
      }
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT'
        }
      },
      schemas: {
        Artist: {
          type: 'object',
          properties: {
            id: { type: 'string' },
            name: { type: 'string' },
            email: { type: 'string' },
            bio: { type: 'string' },
            category: { 
              type: 'string',
              enum: ['dancer', 'musician', 'visual_artist', 'multi_disciplinary']
            },
            experience: {
              type: 'string',
              enum: ['beginner', 'intermediate', 'advanced', 'professional']
            },
            genres: { type: 'array', items: { type: 'string' } },
            location: {
              type: 'object',
              properties: {
                city: { type: 'string' },
                country: { type: 'string' }
              }
            },
            socialLinks: { type: 'object' },
            isActive: { type: 'boolean' },
            isVerified: { type: 'boolean' },
            createdAt: { type: 'string', format: 'date-time' }
          }
        },
        Portfolio: {
          type: 'object',
          properties: {
            id: { type: 'string' },
            artist: { type: 'string' },
            title: { type: 'string' },
            description: { type: 'string' },
            template: { 
              type: 'string',
              enum: ['modern', 'classic', 'creative', 'minimal']
            },
            sections: { type: 'array' },
            isPublic: { type: 'boolean' },
            views: { type: 'number' },
            createdAt: { type: 'string', format: 'date-time' }
          }
        }
      }
    },
    tags: [
      { name: 'Artists', description: 'Artist profile management' },
      { name: 'Portfolios', description: 'Portfolio creation and management' },
      { name: 'Contracts', description: 'Contract templates and guidelines' },
      { name: 'Admin', description: 'Administrative functions' }
    ]
  },
  apis: ['./routes/*.js']
};

const specs = swaggerJsdoc(options);

module.exports = (app) => {
  app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(specs, {
    explorer: true,
    customCss: '.swagger-ui .topbar { display: none }',
    customSiteTitle: 'KatikaNaMe API Documentation'
  }));
};

// ===== MIDDLEWARE/UPLOAD.JS =====
const multer = require('multer');
const path = require('path');
const fs = require('fs');

// Ensure upload directories exist
const ensureDir = (dir) => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
};

// Configure storage
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    let uploadPath = 'uploads/';
    
    // Determine upload path based on route
    if (req.route.path.includes('artist')) {
      uploadPath += 'artists/';
    } else if (req.route.path.includes('portfolio')) {
      uploadPath += 'portfolios/';
    } else {
      uploadPath += 'general/';
    }
    
    ensureDir(uploadPath);
    cb(null, uploadPath);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

// File filter
const fileFilter = (req, file, cb) => {
  const allowedTypes = /jpeg|jpg|png|gif|pdf|mp4|mov|avi|wmv|flv/;
  const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
  const mimetype = allowedTypes.test(file.mimetype);
  
  if (mimetype && extname) {
    return cb(null, true);
  } else {
    cb(new Error('Invalid file type. Only images, PDFs, and videos are allowed.'));
  }
};

const upload = multer({
  storage: storage,
  limits: {
    fileSize: 50 * 1024 * 1024, // 50MB limit
    files: 10 // Maximum 10 files
  },
  fileFilter: fileFilter
});

module.exports = upload;

// ===== .ENV EXAMPLE =====
// Copy this to .env file and fill in your values
NODE_ENV=development
PORT=3000
MONGODB_URI=mongodb://localhost:27017/katikaname
JWT_SECRET=your_super_secret_jwt_key_here_make_it_long_and_random
FRONTEND_URL=http://localhost:3001
API_BASE_URL=http://localhost:3000

# File upload settings
MAX_FILE_SIZE=50MB
ALLOWED_FILE_TYPES=jpeg,jpg,png,gif,pdf,mp4,mov,avi

# Email settings (for notifications)
EMAIL_FROM=noreply@katikaname.com
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your_email@gmail.com
SMTP_PASS=your_app_password

# ===== SCRIPTS/SEED.JS =====
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');
require('dotenv').config();

const Admin = require('../models/Admin');
const Contract = require('../models/Contract');

async function seedDatabase() {
  try {
    await mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/katikaname');
    console.log('Connected to MongoDB for seeding...');

    // Create default admin user
    const adminExists = await Admin.findOne({ username: 'admin' });
    if (!adminExists) {
      const admin = new Admin({
        username: 'admin',
        email: 'admin@katikaname.com',
        password: 'admin123', // Will be hashed by pre-save hook
        role: 'admin',
        permissions: ['read', 'write', 'delete', 'approve']
      });
      
      await admin.save();
      console.log('Default admin user created');
    }

    // Seed contract templates
    const contractTypes = ['performance', 'teaching', 'collaboration', 'commission', 'licensing'];
    
    for (const type of contractTypes) {
      const contractExists = await Contract.findOne({ type });
      if (!contractExists) {
        const contract = new Contract({
          type,
          title: `${type.charAt(0).toUpperCase() + type.slice(1)} Contract Template`,
          description: `Standard template for ${type} agreements`,
          template: `templates/${type}.pdf`
        });
        
        await contract.save();
        console.log(`${type} contract template created`);
      }
    }

    console.log('Database seeding completed successfully!');
    process.exit(0);
  } catch (error) {
    console.error('Seeding error:', error);
    process.exit(1);
  }
}

seedDatabase();

// ===== README.MD =====
# KatikaNaMe Backend

A comprehensive backend API for KatikaNaMe - a creative professional platform connecting dancers, musicians, and visual artists.

## 🚀 Features

- **Artist Profile Management**: Complete CRUD operations for artist profiles
- **Portfolio Generator**: PDF generation with customizable templates
- **Contract Helper**: Legal guidelines and contract templates for creative professionals
- **File Upload Support**: Images, videos, and PDF handling
- **Admin Dashboard**: Protected routes for content moderation
- **RESTful API**: Well-structured endpoints with comprehensive documentation
- **Security**: JWT authentication, rate limiting, and security headers

##
